---
phase: 04-ai-intelligence-settings
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - app/(app)/settings/page.tsx
  - convex/deepgram.ts
  - convex/userSettings.ts
  - convex/transcripts.ts
autonomous: true

must_haves:
  truths:
    - "User can open language dropdown and search/filter available languages"
    - "Selected language persists to Convex and survives page refresh"
    - "Auto-punctuation toggle state persists to Convex and survives page refresh"
    - "New recordings use the selected language in Deepgram API calls"
    - "When auto-punctuation is off, Deepgram requests omit punctuate and smart_format params"
    - "Settings changes only affect future recordings, not existing transcripts"
  artifacts:
    - path: "app/(app)/settings/page.tsx"
      provides: "Interactive language selector and persisted auto-punctuation toggle"
      min_lines: 150
    - path: "convex/deepgram.ts"
      provides: "Dynamic Deepgram URL construction from user settings"
      contains: "language"
    - path: "convex/userSettings.ts"
      provides: "getSettingsForUser internalQuery for use by Deepgram actions"
      contains: "getSettingsForUser"
    - path: "convex/transcripts.ts"
      provides: "getTranscriptOwner internalQuery for looking up transcript userId"
      contains: "getTranscriptOwner"
  key_links:
    - from: "app/(app)/settings/page.tsx"
      to: "convex/userSettings.ts getUserSettings"
      via: "useQuery(api.userSettings.getUserSettings)"
      pattern: "useQuery.*api\\.userSettings\\.getUserSettings"
    - from: "app/(app)/settings/page.tsx"
      to: "convex/userSettings.ts upsertSettings"
      via: "useMutation(api.userSettings.upsertSettings)"
      pattern: "useMutation.*api\\.userSettings\\.upsertSettings"
    - from: "convex/deepgram.ts"
      to: "convex/userSettings.ts"
      via: "Read user settings to build Deepgram URL"
      pattern: "userSettings"
---

<objective>
Make settings page interactive with persisted language/punctuation preferences, and wire them into Deepgram API calls.

Purpose: Users can customize transcription language and auto-punctuation. Settings persist to Convex and are read by the Deepgram action when building API request URLs, so future recordings respect user preferences.

Output: Interactive settings page with searchable language dropdown and persisted toggle. Deepgram URL dynamically built from user settings.
</objective>

<execution_context>
@/Users/lucasalexander/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucasalexander/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ai-intelligence-settings/04-CONTEXT.md
@.planning/phases/04-ai-intelligence-settings/04-RESEARCH.md
@.planning/phases/04-ai-intelligence-settings/04-01-SUMMARY.md
@app/(app)/settings/page.tsx
@convex/deepgram.ts
@convex/userSettings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Interactive settings page with persisted state</name>
  <files>app/(app)/settings/page.tsx</files>
  <action>
    Update the settings page to load/save language and auto-punctuation from Convex instead of local state.

    1. Add imports: useQuery, useMutation from "convex/react", api from "@/convex/_generated/api"

    2. Load settings: `const settings = useQuery(api.userSettings.getUserSettings)`
       Get mutation: `const upsertSettings = useMutation(api.userSettings.upsertSettings)`

    3. Replace the local `autoPunctuation` useState with the Convex value:
       - Read from `settings?.autoPunctuation ?? true`
       - On toggle, call `upsertSettings({ autoPunctuation: !(settings?.autoPunctuation ?? true) })`
       - Keep the Toggle component as-is, just wire `on` and `onToggle` to Convex data

    4. Replace the Language row's static "English" ValueChevron with an interactive language selector:

       Add a `showLanguagePicker` useState(false) boolean.

       When the Language row is tapped (wrap in a clickable div or make the row clickable), set showLanguagePicker to true.

       Create a LanguagePickerModal component (inline in the same file):
       - Full-screen overlay (position: fixed, inset: 0, zIndex: 50, backgroundColor: "rgba(0,0,0,0.4)")
       - Bottom sheet card (position: fixed, bottom: 0, left: 0, right: 0, maxHeight: "70vh", backgroundColor: "#FFF9F0", borderTopLeftRadius: 20, borderTopRightRadius: 20, padding: 16, display: flex, flexDirection: column)
       - Header: "Select Language" title + close button (X icon)
       - Search input: text input with placeholder "Search languages...", styled consistently (backgroundColor: "#F5EDE4", borderRadius: 12, padding: "10px 14px", border: "none", fontSize: 14, width: "100%")
       - Track search with `const [search, setSearch] = useState("")`
       - Scrollable list of languages, filtered by search term (case-insensitive match on name or code)
       - Each language row shows name and code, with a checkmark for the currently selected one
       - On tap, call `upsertSettings({ transcriptionLanguage: code })` and close modal

       Language list (Deepgram Nova-2 supported languages):
       ```
       { code: "en", name: "English" },
       { code: "en-US", name: "English (US)" },
       { code: "en-GB", name: "English (UK)" },
       { code: "en-AU", name: "English (AU)" },
       { code: "en-IN", name: "English (India)" },
       { code: "es", name: "Spanish" },
       { code: "fr", name: "French" },
       { code: "de", name: "German" },
       { code: "it", name: "Italian" },
       { code: "pt", name: "Portuguese" },
       { code: "pt-BR", name: "Portuguese (Brazil)" },
       { code: "nl", name: "Dutch" },
       { code: "ja", name: "Japanese" },
       { code: "ko", name: "Korean" },
       { code: "zh", name: "Chinese" },
       { code: "hi", name: "Hindi" },
       { code: "ru", name: "Russian" },
       { code: "uk", name: "Ukrainian" },
       { code: "pl", name: "Polish" },
       { code: "sv", name: "Swedish" },
       { code: "no", name: "Norwegian" },
       { code: "da", name: "Danish" },
       { code: "fi", name: "Finnish" },
       { code: "tr", name: "Turkish" },
       { code: "id", name: "Indonesian" },
       { code: "ms", name: "Malay" },
       { code: "th", name: "Thai" },
       { code: "vi", name: "Vietnamese" },
       { code: "ta", name: "Tamil" },
       { code: "tl", name: "Tagalog" },
       ```

    5. Update the Language ValueChevron to show the current language name (look up from list by code) instead of hardcoded "English". Make the entire row clickable to open the picker.

    6. Keep detectSpeakers and autoSave as local state (they are not part of Phase 4 requirements -- leave them as-is for future phases).

    7. While settings is undefined (loading), show the current UI with default values to avoid flash. The Convex reactive query will update automatically.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors. In browser: go to Settings, verify language shows current selection, tap to open picker, search works, selecting a language closes modal and updates display. Toggle auto-punctuation and refresh page -- state should persist.</verify>
  <done>Language selector opens searchable bottom sheet, selection persists to Convex. Auto-punctuation toggle reads/writes Convex. Both survive page refresh. No impact on existing non-settings features.</done>
</task>

<task type="auto">
  <name>Task 2: Wire user settings into Deepgram API URL</name>
  <files>convex/deepgram.ts, convex/userSettings.ts, convex/transcripts.ts</files>
  <action>
    Modify both `transcribeChunk` and `transcribeFile` actions in convex/deepgram.ts to read user settings and build the Deepgram URL dynamically.

    1. Import the userSettings query. Since actions can use ctx.runQuery, import the internal API:
       - Add to the action handler: query userSettings table directly using `ctx.runQuery` with the internal query, OR since we need the userId, get it from auth first then query the userSettings table.
       - Actually, Convex actions cannot directly query the database. Instead, create an `internalQuery` in userSettings.ts called `getSettingsForUser` that takes userId as arg and returns settings. Then call it from the action via `ctx.runQuery(internal.userSettings.getSettingsForUser, { userId })`.
       - First, add to convex/userSettings.ts:
         ```typescript
         export const getSettingsForUser = internalQuery({
           args: { userId: v.id("users") },
           handler: async (ctx, args) => {
             const settings = await ctx.db
               .query("userSettings")
               .withIndex("by_userId", (q) => q.eq("userId", args.userId))
               .first();
             return settings ?? { transcriptionLanguage: "en", autoPunctuation: true };
           },
         });
         ```
       - Import `internalQuery` from "./_generated/server" in userSettings.ts.

    2. In deepgram.ts, import `internal` from "./_generated/api" (already imported) and `auth` from "./auth".

    3. In `transcribeChunk` handler:
       - Get userId: Since this is an action and auth.getUserId requires a query/mutation context, we need an alternative. The transcriptId is passed in -- we can look up the transcript's userId. But actions can't query DB directly.
       - Better approach: Add a `userId` arg to transcribeChunk. The client already knows the userId. OR create an internal query to get the transcript's userId.
       - Simplest: Create an internalQuery `getTranscriptOwner` in transcripts.ts that takes transcriptId and returns userId. Then in deepgram.ts actions, get userId from that, then get settings.
       - Actually, even simpler: Add an internalQuery to transcripts.ts:
         ```typescript
         export const getTranscriptOwner = internalQuery({
           args: { transcriptId: v.id("transcripts") },
           handler: async (ctx, args) => {
             const transcript = await ctx.db.get(args.transcriptId);
             return transcript?.userId ?? null;
           },
         });
         ```
       - In transcribeChunk, after getting apiKey:
         ```typescript
         const userId = await ctx.runQuery(internal.transcripts.getTranscriptOwner, { transcriptId: args.transcriptId });
         const settings = userId ? await ctx.runQuery(internal.userSettings.getSettingsForUser, { userId }) : { transcriptionLanguage: "en", autoPunctuation: true };
         ```
       - Build URL dynamically:
         ```typescript
         const lang = settings.transcriptionLanguage || "en";
         const params = [`model=nova-2`, `diarize=true`, `language=${lang}`];
         if (settings.autoPunctuation !== false) {
           params.push("punctuate=true", "smart_format=true");
         }
         const url = `https://api.deepgram.com/v1/listen?${params.join("&")}`;
         ```
       - Replace the hardcoded URL string with the dynamic `url` variable.

    4. In `transcribeFile` handler:
       - Same pattern: get userId via getTranscriptOwner, get settings, build URL dynamically.
       - Replace the hardcoded URL with dynamic version.

    5. Import `internalQuery` in convex/transcripts.ts and add the getTranscriptOwner function. Import `internalQuery` in convex/userSettings.ts and add getSettingsForUser.
  </action>
  <verify>Run `npx convex dev --once` to verify all functions deploy. Check that transcribeChunk and transcribeFile no longer have hardcoded Deepgram URLs. Verify the URL builder includes language param and conditionally includes punctuate/smart_format.</verify>
  <done>Deepgram API calls use dynamic URL built from user settings. Language setting applied to both recording and file upload transcription. When auto-punctuation is off, punctuate and smart_format params are omitted. Default behavior (English, punctuation on) matches previous hardcoded behavior.</done>
</task>

</tasks>

<verification>
- `npm run build` and `npx convex dev --once` both complete without errors
- Settings page loads language and auto-punctuation from Convex
- Language picker modal opens, filters languages, selects and persists
- Auto-punctuation toggle persists across page refresh
- Deepgram URL in deepgram.ts is dynamically built from settings
- Default settings (en, punctuation on) produce same URL as before (backward compatible)
</verification>

<success_criteria>
- User can select transcription language from searchable dropdown in settings
- User can toggle auto-punctuation on/off and see it persist
- Future recordings use selected language in Deepgram API calls
- When auto-punctuation off, Deepgram omits punctuate and smart_format
- Existing transcripts unaffected by settings changes
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-intelligence-settings/04-03-SUMMARY.md`
</output>
