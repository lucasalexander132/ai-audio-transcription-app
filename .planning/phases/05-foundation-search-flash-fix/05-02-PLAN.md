---
phase: 05-foundation-search-flash-fix
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/motion/features.ts
  - app/components/providers/motion-provider.tsx
  - app/(app)/layout.tsx
  - app/globals.css
autonomous: true

must_haves:
  truths:
    - "Motion library is installed and loadable via LazyMotion (async chunk load, not blocking initial bundle)"
    - "Users with reduce motion enabled in their OS settings see no animations throughout the app"
  artifacts:
    - path: "app/lib/motion/features.ts"
      provides: "Async feature loader for LazyMotion"
      exports: ["default"]
      contains: "domAnimation"
    - path: "app/components/providers/motion-provider.tsx"
      provides: "LazyMotion + MotionConfig wrapper"
      exports: ["MotionProvider"]
      contains: "LazyMotion"
    - path: "app/(app)/layout.tsx"
      provides: "MotionProvider wrapping app children"
      contains: "MotionProvider"
    - path: "app/globals.css"
      provides: "CSS reduced-motion baseline"
      contains: "prefers-reduced-motion"
  key_links:
    - from: "app/(app)/layout.tsx"
      to: "app/components/providers/motion-provider.tsx"
      via: "import MotionProvider"
      pattern: "import.*MotionProvider.*motion-provider"
    - from: "app/components/providers/motion-provider.tsx"
      to: "app/lib/motion/features.ts"
      via: "dynamic import for LazyMotion features prop"
      pattern: "import.*motion/features"
    - from: "app/components/providers/motion-provider.tsx"
      to: "motion/react"
      via: "LazyMotion and MotionConfig imports"
      pattern: "from.*motion/react"
---

<objective>
Install the motion animation library and establish the animation foundation (LazyMotion code-splitting, MotionConfig reduced-motion, CSS baseline) that Phases 06-08 will build upon.

Purpose: This sets up the animation infrastructure without adding any visible animations yet. LazyMotion ensures the ~34kb motion bundle is loaded asynchronously (not blocking initial render). MotionConfig with reducedMotion="user" respects OS accessibility settings. The CSS baseline catches any CSS transitions/animations that MotionConfig doesn't cover.

Output: motion installed, feature loader, MotionProvider component wrapping the app, and CSS reduced-motion media query in globals.css.
</objective>

<execution_context>
@/Users/lucasalexander/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucasalexander/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-foundation-search-flash-fix/05-RESEARCH.md

@app/(app)/layout.tsx
@app/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install motion and create LazyMotion feature loader</name>
  <files>
    app/lib/motion/features.ts
  </files>
  <action>
**Step 1: Install the motion package.**

Run: `npm install motion`

This installs `motion` v12+ which has native React 19 support (peer deps `^18.0.0 || ^19.0.0`). Do NOT install `framer-motion` -- that's the old package name and has React 19 compatibility issues.

**Step 2: Create the async feature loader.**

Create `app/lib/motion/features.ts`:

```typescript
"use client";

import { domAnimation } from "motion/react";
export default domAnimation;
```

This file exists solely to be dynamically imported by LazyMotion. By putting domAnimation in its own module, webpack/turbopack can split it into a separate async chunk (~6kb instead of the full ~34kb motion bundle).

**Important:** Use `domAnimation` (not `domMax`). `domMax` adds ~10kb for drag and layout features that aren't needed until Phase 06. We can upgrade to `domMax` later when layout animations are needed.
  </action>
  <verify>
1. Verify `motion` is in package.json dependencies: `grep '"motion"' package.json`
2. Verify file exists: `cat app/lib/motion/features.ts`
3. Run `npx tsc --noEmit` to confirm no TypeScript errors with the motion imports
  </verify>
  <done>
- `motion` package is installed in dependencies
- `app/lib/motion/features.ts` exists, exports `domAnimation` as default
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MotionProvider, wire into app layout, add CSS reduced-motion baseline</name>
  <files>
    app/components/providers/motion-provider.tsx
    app/(app)/layout.tsx
    app/globals.css
  </files>
  <action>
**Step 1: Create the MotionProvider component.**

Create `app/components/providers/motion-provider.tsx`:

```typescript
"use client";

import { LazyMotion, MotionConfig } from "motion/react";

const loadFeatures = () =>
  import("@/app/lib/motion/features").then((mod) => mod.default);

export function MotionProvider({ children }: { children: React.ReactNode }) {
  return (
    <LazyMotion features={loadFeatures} strict>
      <MotionConfig reducedMotion="user">
        {children}
      </MotionConfig>
    </LazyMotion>
  );
}
```

Key details:
- `strict` prop on LazyMotion ensures that if any component accidentally uses `motion.div` instead of `m.div`, it throws an error rather than silently loading the full bundle
- `reducedMotion="user"` reads the OS-level `prefers-reduced-motion` setting and disables transform/layout animations while preserving opacity and color transitions
- The `loadFeatures` function is defined outside the component to avoid recreating the import on every render

**Step 2: Wrap the app layout with MotionProvider.**

In `app/(app)/layout.tsx`, add the MotionProvider import and wrap children:

```typescript
import { MotionProvider } from "../components/providers/motion-provider";
```

Then in the return JSX, wrap `{children}` with `<MotionProvider>`:

```tsx
return (
  <div className="min-h-screen bg-background">
    <MotionProvider>
      {children}
    </MotionProvider>
    <FABMenu />
  </div>
);
```

Place MotionProvider inside the `<div>` but wrapping `{children}`. Keep `<FABMenu />` OUTSIDE MotionProvider -- the FAB doesn't need animations in this phase and keeping it outside avoids re-renders.

**Step 3: Add CSS reduced-motion baseline to globals.css.**

Append this media query to the END of `app/globals.css`:

```css
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}
```

This catches CSS-based animations/transitions that MotionConfig doesn't control (e.g., Tailwind's `animate-pulse` used in loading skeletons, any `transition` properties in inline styles). The `0.01ms` duration (not `0s`) avoids issues with animation event listeners that depend on `animationend` firing.

**What NOT to do:**
- Do NOT wrap the root layout.tsx (app/layout.tsx) -- MotionProvider is a client component and the root layout is a server component. Wrap at the (app)/layout.tsx level which is already "use client".
- Do NOT import from `motion/react-m` yet -- we have no animated components in this phase. That's for Phase 06+.
- Do NOT use `domMax` in the features loader -- `domAnimation` is sufficient for now.
  </action>
  <verify>
1. Run `npx tsc --noEmit` to confirm no TypeScript errors
2. Run `npm run build` to confirm the build succeeds
3. Start dev server with `npm run dev` and verify:
   - App loads normally (no visual changes expected)
   - Open browser dev tools Network tab, navigate to any (app) page, and look for a separate chunk containing "motion" or "domAnimation" -- confirms LazyMotion is code-splitting
   - Check that `prefers-reduced-motion: reduce` CSS rule exists in globals.css
  </verify>
  <done>
- `motion-provider.tsx` exists and exports `MotionProvider` with LazyMotion + MotionConfig
- `(app)/layout.tsx` wraps children with MotionProvider
- `globals.css` has the `prefers-reduced-motion: reduce` media query
- App builds and runs without errors
- Motion features load as async chunk (not in main bundle)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Motion library loads as async chunk (verifiable in dev tools Network tab)
4. CSS reduced-motion rule is present in globals.css
5. App functions identically to before (no visible changes, no regressions)
</verification>

<success_criteria>
- motion library is installed and code-split via LazyMotion (async chunk, not blocking initial bundle)
- MotionConfig with reducedMotion="user" is active for all (app) pages
- CSS baseline disables CSS animations/transitions when OS reduce-motion is enabled
- No visual regressions -- app looks and works exactly as before
</success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-search-flash-fix/05-02-SUMMARY.md`
</output>
