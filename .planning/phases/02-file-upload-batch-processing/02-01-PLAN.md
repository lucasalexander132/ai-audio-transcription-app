---
phase: 02-file-upload-batch-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/deepgram.ts
  - convex/transcripts.ts
autonomous: true

must_haves:
  truths:
    - "Uploaded audio files are transcribed via Deepgram with speaker diarization and timestamps"
    - "Transcript status transitions from processing to completed (or error) after file transcription"
    - "Transcription errors are captured and stored on the transcript record"
  artifacts:
    - path: "convex/schema.ts"
      provides: "processing status, source field, errorMessage field on transcripts table"
      contains: "literal(\"processing\")"
    - path: "convex/deepgram.ts"
      provides: "transcribeFile action that reads from Convex storage and sends to Deepgram"
      exports: ["transcribeFile"]
    - path: "convex/transcripts.ts"
      provides: "createFromUpload mutation, completeTranscript internal mutation, markError internal mutation, setStatus internal mutation"
      exports: ["createFromUpload", "completeTranscript", "markError", "setStatus"]
  key_links:
    - from: "convex/deepgram.ts"
      to: "convex/transcripts.ts"
      via: "ctx.runMutation(internal.transcripts.appendWords)"
      pattern: "internal\\.transcripts\\.appendWords"
    - from: "convex/deepgram.ts"
      to: "convex/transcripts.ts"
      via: "ctx.runMutation(internal.transcripts.completeTranscript)"
      pattern: "internal\\.transcripts\\.completeTranscript"
    - from: "convex/deepgram.ts"
      to: "Deepgram REST API"
      via: "fetch to /v1/listen with storage blob"
      pattern: "api\\.deepgram\\.com/v1/listen"
---

<objective>
Add backend infrastructure for file upload transcription: extend the schema with "processing" status, source tracking, and error message fields; create a `transcribeFile` Convex action that reads uploaded audio from storage and sends it to Deepgram; add supporting mutations for the upload workflow.

Purpose: Enable server-side transcription of uploaded audio files, reusing the existing Deepgram REST API pattern from Phase 1.
Output: Extended schema, `transcribeFile` action, and upload-specific mutations ready for the frontend to consume.
</objective>

<execution_context>
@/Users/lucasalexander/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucasalexander/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-file-upload-batch-processing/02-RESEARCH.md

@convex/schema.ts
@convex/deepgram.ts
@convex/transcripts.ts
@convex/recordings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend schema and add upload mutations</name>
  <files>convex/schema.ts, convex/transcripts.ts</files>
  <action>
  **Schema changes (convex/schema.ts):**
  1. Add `v.literal("processing")` to the `status` union on the `transcripts` table (between "recording" and "completed")
  2. Add `source: v.optional(v.union(v.literal("recording"), v.literal("upload")))` field to transcripts table
  3. Add `errorMessage: v.optional(v.string())` field to transcripts table

  **New mutations (convex/transcripts.ts):**
  1. Add `createFromUpload` — a public mutation (authenticated) that creates a transcript with `status: "processing"` and `source: "upload"`. Args: `{ title: v.string() }`. Returns the transcript ID. Similar to existing `create` but sets status to "processing" and source to "upload".

  2. Add `setStatus` — an internal mutation that updates transcript status. Args: `{ transcriptId: v.id("transcripts"), status: v.string() }`. Used by the action to mark transcripts as "processing".

  3. Add `completeTranscript` — an internal mutation that marks transcript as completed with duration. Args: `{ transcriptId: v.id("transcripts"), duration: v.number() }`. Sets status to "completed", completedAt to Date.now(), and duration to the provided value.

  4. Add `markError` — an internal mutation that marks transcript as errored. Args: `{ transcriptId: v.id("transcripts"), error: v.string() }`. Sets status to "error" and errorMessage to the provided error string.

  Import `internalMutation` if not already imported (it is already imported). All internal mutations should check that the transcript exists before patching.
  </action>
  <verify>
  Run `npx convex dev --once` or check that `npx convex typecheck` passes. Verify schema compiles by checking convex/_generated types are regenerated without errors.
  </verify>
  <done>
  - Schema has "processing" status, "source" field, and "errorMessage" field
  - createFromUpload mutation creates transcripts with status "processing" and source "upload"
  - setStatus, completeTranscript, and markError internal mutations exist and handle transcript state transitions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create transcribeFile Convex action</name>
  <files>convex/deepgram.ts</files>
  <action>
  Add a new `transcribeFile` action to `convex/deepgram.ts` alongside the existing `transcribeChunk` action.

  **Action definition:**
  ```
  export const transcribeFile = action({
    args: {
      transcriptId: v.id("transcripts"),
      storageId: v.id("_storage"),
      mimeType: v.string(),
    },
    handler: async (ctx, args) => { ... }
  });
  ```

  **Handler logic:**
  1. Get DEEPGRAM_API_KEY from process.env, throw if missing
  2. Read uploaded file from Convex storage: `const blob = await ctx.storage.get(args.storageId);` — throw if null ("File not found in storage")
  3. Convert to Uint8Array: `const audioBytes = new Uint8Array(await blob.arrayBuffer());`
  4. Strip codec params from MIME type: `const contentType = args.mimeType.split(";")[0].trim();`
  5. POST to Deepgram REST endpoint: `https://api.deepgram.com/v1/listen?model=nova-2&diarize=true&punctuate=true&smart_format=true` with Authorization header `Token ${apiKey}`, Content-Type header from contentType, body as audioBytes
  6. If response is not ok: call `ctx.runMutation(internal.transcripts.markError, { transcriptId, error: "Transcription failed: {status}" })` and return
  7. Parse response JSON, extract words from `result.results.channels[0].alternatives[0].words` (default to empty array)
  8. Extract duration from `result.metadata.duration` (default to 0)
  9. If words.length > 0: call `ctx.runMutation(internal.transcripts.appendWords, { ... })` mapping each word to `{ text: w.punctuated_word || w.word, speaker: w.speaker ?? 0, startTime: w.start, endTime: w.end, isFinal: true }`. **IMPORTANT:** Use `punctuated_word` (not `word`) for properly formatted text with punctuation and casing.
  10. Call `ctx.runMutation(internal.transcripts.completeTranscript, { transcriptId, duration: Math.round(duration) })` to mark complete

  Wrap steps 2-10 in a try/catch. On error, call markError with the error message.

  Make sure `internal` is imported from `./_generated/api` (it already is in the file).
  </action>
  <verify>
  Run `npx convex dev --once` to verify the action compiles and deploys. Check that the function appears in the Convex dashboard functions list.
  </verify>
  <done>
  - transcribeFile action exists in convex/deepgram.ts
  - Action reads from Convex storage (not action args) to handle large files
  - Uses punctuated_word for properly formatted text
  - Handles errors gracefully by marking transcript as "error" with message
  - Calls completeTranscript on success with duration from Deepgram metadata
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` succeeds without type errors
2. Schema includes "processing" status, "source" field, and "errorMessage" field
3. transcribeFile action is registered and callable
4. All internal mutations (setStatus, completeTranscript, markError) are accessible via `internal.transcripts.*`
</verification>

<success_criteria>
- Extended schema deploys successfully to Convex
- transcribeFile action compiles and can be invoked with transcriptId, storageId, and mimeType
- The existing transcribeChunk action and all Phase 1 functionality remain unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-upload-batch-processing/02-01-SUMMARY.md`
</output>
